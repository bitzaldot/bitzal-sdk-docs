<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Learn about how extrinsics are encoded to be transmitted to a node and stored in blocks."><title>bitzal_sdk_docs::reference_docs::extrinsic_encoding - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin="" href="../../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-5bc39a1768837dd0.css"><script id="default-settings" data-theme="ayu" data-use_system_theme="false"></script><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="bitzal_sdk_docs" data-themes="" data-resource-suffix="" data-rustdoc-version="1.77.0 (aedd173a2 2024-03-17)" data-channel="1.77.0" data-search-js="search-dd67cee4cfa65049.js" data-settings-js="settings-4313503d2e1961c2.js"><script src="../../../static.files/storage-4c98445ec4002617.js"></script><script defer="" src="../sidebar-items.js"></script><script defer="" src="../../../static.files/main-48f368f3872407c8.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-04d5337699b92874.css"></noscript><link rel="stylesheet" href="../../../theme.css"><link rel="icon" href="../../../../../favicon.ico"><script>
	function createToC() {
		let sidebar = document.querySelector(".sidebar");
		let headers = document.querySelectorAll("#main-content h2, #main-content h3, #main-content h4");
		console.log(`detected bitzal_sdk_docs: headers: ${headers.length}`);

		let toc = document.createElement("div");
		toc.classList.add("sidebar-table-of-contents");
		toc.appendChild(document.createElement("h2").appendChild(document.createTextNode("Table of Contents")).parentNode);

		let modules = document.querySelectorAll("main .item-table a.mod");

		// the first two headers are always junk
		headers.forEach(header => {
			let link = document.createElement("a");
			link.href = "#" + header.id;
			const headerTextContent = header.textContent.replace("§", "")
			link.textContent = headerTextContent;
			link.className = header.tagName.toLowerCase();

			toc.appendChild(link);

			if (header.id == "modules" && headerTextContent == "Modules") {
				modules.forEach(module => {
					let link = document.createElement("a");
					link.href = module.href;
					link.textContent = module.textContent;
					link.className = "h3";

					toc.appendChild(link);
				});
			}
		});

		// insert toc as the second child in sidebar
		let sidebar_children = sidebar.children;
		if (sidebar_children.length > 1) {
			sidebar.insertBefore(toc, sidebar_children[1]);
		} else {
			sidebar.appendChild(toc);
		}
	}

	function hideSidebarElements() {
		// Create the 'Expand for More' button
		var expandButton = document.createElement('button');
		expandButton.innerText = 'Expand More Items';
		expandButton.classList.add('expand-button');

		// Insert the button at the top of the sidebar or before the '.sidebar-elems'
		var sidebarElems = document.querySelector('.sidebar-elems');
		sidebarElems.parentNode.insertBefore(expandButton, sidebarElems);

		// Initially hide the '.sidebar-elems'
		sidebarElems.style.display = 'none';

		// Add click event listener to the button
		expandButton.addEventListener('click', function () {
			// Toggle the display of the '.sidebar-elems'
			if (sidebarElems.style.display === 'none') {
				sidebarElems.style.display = 'block';
				expandButton.innerText = 'Collapse';
			} else {
				sidebarElems.style.display = 'none';
				expandButton.innerText = 'Expand for More';
			}
		});
	}

	window.addEventListener("DOMContentLoaded", (event) => {
		// if the crate is one that starts with `bitzal_sdk_docs`
		let crate_name = document.querySelector("#main-content > div > h1 > a:nth-child(1)");
		if (!crate_name.textContent.startsWith("bitzal_sdk_docs")) {
			console.log("skipping -- not `bitzal_sdk_docs`");
			return;
		} else {
			// insert class 'sdk-docs' to the body, so it enables the custom css rules.
			document.body.classList.add("sdk-docs");
		}

		createToC();
		hideSidebarElements();

		console.log("updating page based on being `bitzal_sdk_docs` crate");
	});
</script>

<script src="../../../../../npm/mermaid/dist/mermaid.min.js"></script>

<style>
	body.sdk-docs {
		nav.side-bar {
			width: 300px;
		}

		.sidebar-table-of-contents {
			margin-bottom: 1em;
			padding: 0.5em;
		}

		.sidebar-table-of-contents a {
			display: block;
			margin: 0.2em 0;
		}

		.sidebar-table-of-contents .h2 {
			font-weight: bold;
			margin-left: 0;
		}

		.sidebar-table-of-contents .h3 {
			margin-left: 1em;
		}

		.sidebar-table-of-contents .h4 {
			margin-left: 2em;
		}

		.sidebar h2.location {
			display: none;
		}

		.sidebar-elems {
			display: none;
		}

		/* Center the 'Expand for More' button */
		.expand-button {
			display: inline-block;
			/* Use inline-block for sizing */
			margin: 10px auto;
			/* Auto margins for horizontal centering */
			padding: 5px 10px;
			background-color: #007bff;
			color: white;
			text-align: center;
			cursor: pointer;
			border: none;
			border-radius: 5px;
			width: auto;
			/* Centering the button within its parent container */
			position: relative;
			left: 50%;
			transform: translateX(-50%);
		}
	}
</style>

<script async="" defer="" src="../../../../../latest.js"></script><noscript><img src="../../../../../latest.js" alt="" referrerpolicy="no-referrer-when-downgrade"></noscript></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button><a class="logo-container" href="../../index.html"><img src="../../../static.files/logos.png" alt=""></a></nav><nav class="sidebar"><div class="sidebar-crate"><a class="logo-container" href="../../index.html"><img src="../../../static.files/logos.png" alt="logo"></a><h2><a href="../../index.html">bitzal_sdk_docs</a><span class="version">0.0.1</span></h2></div><h2 class="location"><a href="#">Module extrinsic_encoding</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#modules">Modules</a></li></ul></section><h2><a href="../index.html">In bitzal_sdk_docs::reference_docs</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../../index.html">bitzal_sdk_docs</a>::<wbr><a href="../index.html">reference_docs</a>::<wbr><a class="mod" href="#">extrinsic_encoding</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../../src/bitzal_sdk_docs/reference_docs/extrinsic_encoding.rs.html#1-277">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open=""><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Learn about how extrinsics are encoded to be transmitted to a node and stored in blocks.</p>
<h2 id="constructing-and-signing-extrinsics"><a class="doc-anchor" href="#constructing-and-signing-extrinsics">§</a>Constructing and Signing Extrinsics</h2>
<p>Extrinsics are payloads that are stored in blocks which are responsible for altering the state
of a blockchain via the <a href="../blockchain_state_machines/index.html" title="mod bitzal_sdk_docs::reference_docs::blockchain_state_machines"><em>state transition
function</em></a>.</p>
<p>Substrate is configurable enough that extrinsics can take any format. In practice, runtimes
tend to use our <a href="../../../sp_runtime/generic/unchecked_extrinsic/struct.UncheckedExtrinsic.html" title="struct sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic"><code>sp_runtime::generic::UncheckedExtrinsic</code></a> type to represent extrinsics,
because it’s generic enough to cater for most (if not all) use cases. In bitzal, this is
configured <a href="https://github.com/bitzal-fellows/runtimes/blob/94b2798b69ba6779764e20a50f056e48db78ebef/relay/bitzal/src/lib.rs#L1478">here</a>
at the time of writing.</p>
<p>What follows is a description of how extrinsics based on this
<a href="../../../sp_runtime/generic/unchecked_extrinsic/struct.UncheckedExtrinsic.html" title="struct sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic"><code>sp_runtime::generic::UncheckedExtrinsic</code></a> type are encoded into bytes. Specifically, we are
looking at how extrinsics with a format version of 4 are encoded. This version is itself a part
of the payload, and if it changes, it indicates that something about the encoding may have
changed.</p>
<h2 id="encoding-an-extrinsic"><a class="doc-anchor" href="#encoding-an-extrinsic">§</a>Encoding an Extrinsic</h2>
<p>At a high level, all extrinsics compatible with <a href="../../../sp_runtime/generic/unchecked_extrinsic/struct.UncheckedExtrinsic.html" title="struct sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic"><code>sp_runtime::generic::UncheckedExtrinsic</code></a>
are formed from concatenating some details together, as in the following pseudo-code:</p>
<div class="example-wrap"><pre class="language-text"><code>extrinsic_bytes = concat(
    compact_encoded_length,
    version_and_maybe_signature,
    call_data
)
</code></pre></div>
<p>For clarity, the actual implementation in Substrate looks like this:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">impl</span>&lt;Address, Call, Signature, Extra&gt; Encode <span class="kw">for </span>UncheckedExtrinsic&lt;Address, Call, Signature, Extra&gt;
<span class="kw">where
	</span>Address: Encode,
	Signature: Encode,
	Call: Encode,
	Extra: SignedExtension,
{
	<span class="kw">fn </span>encode(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; Vec&lt;u8&gt; {
		<span class="kw">let </span><span class="kw-2">mut </span>tmp = Vec::with_capacity(core::mem::size_of::&lt;<span class="self">Self</span>&gt;());

		<span class="comment">// 1 byte version id.
		</span><span class="kw">match </span><span class="self">self</span>.signature.as_ref() {
			<span class="prelude-val">Some</span>(s) =&gt; {
				tmp.push(EXTRINSIC_FORMAT_VERSION | <span class="number">0b1000_0000</span>);
				s.encode_to(<span class="kw-2">&amp;mut </span>tmp);
			},
			<span class="prelude-val">None </span>=&gt; {
				tmp.push(EXTRINSIC_FORMAT_VERSION &amp; <span class="number">0b0111_1111</span>);
			},
		}
		<span class="self">self</span>.function.encode_to(<span class="kw-2">&amp;mut </span>tmp);

		<span class="kw">let </span>compact_len = codec::Compact::&lt;u32&gt;(tmp.len() <span class="kw">as </span>u32);

		<span class="comment">// Allocate the output buffer with the correct length
		</span><span class="kw">let </span><span class="kw-2">mut </span>output = Vec::with_capacity(compact_len.size_hint() + tmp.len());

		compact_len.encode_to(<span class="kw-2">&amp;mut </span>output);
		output.extend(tmp);

		output
	}
}</code></pre></div>
<p>Let’s look at how each of these details is constructed:</p>
<h3 id="compact_encoded_length"><a class="doc-anchor" href="#compact_encoded_length">§</a>compact_encoded_length</h3>
<p>This is a [SCALE compact encoded][frame::deps::codec::Compact] integer which is equal to the
length, in bytes, of the rest of the extrinsic details.</p>
<p>To obtain this value, we must encode and concatenate together the rest of the extrinsic details
first, and then obtain the byte length of these. We can then compact encode that length, and
prepend it to the rest of the details.</p>
<h3 id="version_and_maybe_signature"><a class="doc-anchor" href="#version_and_maybe_signature">§</a>version_and_maybe_signature</h3>
<p>If the extrinsic is <em>unsigned</em>, then <code>version_and_maybe_signature</code> will be just one byte
denoting the <em>transaction protocol version</em>, which is 4 (or <code>0b0000_0100</code>).</p>
<p>If the extrinsic is <em>signed</em> (all extrinsics submitted from users must be signed), then
<code>version_and_maybe_signature</code> is obtained by concatenating some details together, ie:</p>
<div class="example-wrap"><pre class="language-text"><code>version_and_maybe_signature = concat(
    version_and_signed,
    from_address,
    signature,
    signed_extensions_extra,
)
</code></pre></div>
<p>Each of the details to be concatenated together is explained below:</p>
<h4 id="version_and_signed"><a class="doc-anchor" href="#version_and_signed">§</a>version_and_signed</h4>
<p>This is one byte, equal to <code>0x84</code> or <code>0b1000_0100</code> (i.e. an upper 1 bit to denote that it is
signed, and then the transaction version, 4, in the lower bits).</p>
<h4 id="from_address"><a class="doc-anchor" href="#from_address">§</a>from_address</h4>
<p>This is the [SCALE encoded][frame::deps::codec] address of the sender of the extrinsic. The
address is the first generic parameter of <a href="../../../sp_runtime/generic/unchecked_extrinsic/struct.UncheckedExtrinsic.html" title="struct sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic"><code>sp_runtime::generic::UncheckedExtrinsic</code></a>, and so
can vary from chain to chain.</p>
<p>The address type used on the bitzal relay chain is <a href="../../../sp_runtime/multiaddress/enum.MultiAddress.html" title="enum sp_runtime::multiaddress::MultiAddress"><code>sp_runtime::MultiAddress&lt;AccountId32&gt;</code></a>,
where <code>AccountId32</code> is defined <a href="../../../sp_core/crypto/struct.AccountId32.html" title="struct sp_core::crypto::AccountId32">here</a>. When constructing a
signed extrinsic to be submitted to a bitzal node, you’ll always use the
<a href="../../../sp_runtime/multiaddress/enum.MultiAddress.html#variant.Id" title="variant sp_runtime::multiaddress::MultiAddress::Id"><code>sp_runtime::MultiAddress::Id</code></a> variant to wrap your <code>AccountId32</code>.</p>
<h4 id="signature"><a class="doc-anchor" href="#signature">§</a>signature</h4>
<p>This is the [SCALE encoded][frame::deps::codec] signature. The signature type is configured via
the third generic parameter of <a href="../../../sp_runtime/generic/unchecked_extrinsic/struct.UncheckedExtrinsic.html" title="struct sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic"><code>sp_runtime::generic::UncheckedExtrinsic</code></a>, which determines the
shape of the signature and signing algorithm that should be used.</p>
<p>The signature is obtained by signing the <em>signed payload</em> bytes (see below on how this is
constructed) using the private key associated with the address and correct algorithm.</p>
<p>The signature type used on the bitzal relay chain is <a href="../../../sp_runtime/enum.MultiSignature.html" title="enum sp_runtime::MultiSignature"><code>sp_runtime::MultiSignature</code></a>; the
variants there are the types of signature that can be provided.</p>
<h4 id="signed_extensions_extra"><a class="doc-anchor" href="#signed_extensions_extra">§</a>signed_extensions_extra</h4>
<p>This is the concatenation of the [SCALE encoded][frame::deps::codec] bytes representing each of
the <a href="../../../sp_runtime/traits/trait.SignedExtension.html" title="trait sp_runtime::traits::SignedExtension"><em>signed extensions</em></a>, and are configured by the
fourth generic parameter of <a href="../../../sp_runtime/generic/unchecked_extrinsic/struct.UncheckedExtrinsic.html" title="struct sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic"><code>sp_runtime::generic::UncheckedExtrinsic</code></a>. Learn more about
signed extensions <a href="../signed_extensions/index.html" title="mod bitzal_sdk_docs::reference_docs::signed_extensions">here</a>.</p>
<p>When it comes to constructing an extrinsic, each signed extension has two things that we are
interested in here:</p>
<ul>
<li>The actual SCALE encoding of the signed extension type itself; this is what will form our
<code>signed_extensions_extra</code> bytes.</li>
<li>An <code>AdditionalSigned</code> type. This is SCALE encoded into the <code>signed_extensions_additional</code> data
of the <em>signed payload</em> (see below).</li>
</ul>
<p>Either (or both) of these can encode to zero bytes.</p>
<p>Each chain configures the set of signed extensions that it uses in its runtime configuration.
At the time of writing, bitzal configures them
<a href="https://github.com/bitzal-fellows/runtimes/blob/1dc04eb954eadf8aadb5d83990b89662dbb5a074/relay/bitzal/src/lib.rs#L1432C25-L1432C25">here</a>.
Some of the common signed extensions are defined
<a href="../../../frame_system/index.html#signed-extensions" title="mod frame_system">here</a>.</p>
<p>Information about exactly which signed extensions are present on a chain and in what order is
also a part of the metadata for the chain. For V15 metadata, it can be
[found here][frame::deps::frame_support::__private::metadata::v15::ExtrinsicMetadata].</p>
<h3 id="call_data"><a class="doc-anchor" href="#call_data">§</a>call_data</h3>
<p>This is the main payload of the extrinsic, which is used to determine how the chain’s state is
altered. This is defined by the second generic parameter of
<a href="../../../sp_runtime/generic/unchecked_extrinsic/struct.UncheckedExtrinsic.html" title="struct sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic"><code>sp_runtime::generic::UncheckedExtrinsic</code></a>.</p>
<p>A call can be anything that implements [<code>Encode</code>][frame::deps::codec::Encode]. In FRAME-based
runtimes, a call is represented as an enum of enums, where the outer enum represents the FRAME
pallet being called, and the inner enum represents the call being made within that pallet, and
any arguments to it. Read more about the call enum
<a href="../frame_runtime_types/index.html" title="mod bitzal_sdk_docs::reference_docs::frame_runtime_types">here</a>.</p>
<p>FRAME <code>Call</code> enums are automatically generated, and end up looking something like this:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">pub mod </span>call_data {
	<span class="kw">use </span>codec::{Decode, Encode};

	<span class="comment">// The outer enum composes calls within
	// different pallets together. We have two
	// pallets, "PalletA" and "PalletB".
	</span><span class="attr">#[derive(Encode, Decode)]
	</span><span class="kw">pub enum </span>Call {
		<span class="attr">#[codec(index = <span class="number">0</span>)]
		</span>PalletA(PalletACall),
		<span class="attr">#[codec(index = <span class="number">7</span>)]
		</span>PalletB(PalletBCall),
	}

	<span class="comment">// An inner enum represents the calls within
	// a specific pallet. "PalletA" has one call,
	// "Foo".
	</span><span class="attr">#[derive(Encode, Decode)]
	</span><span class="kw">pub enum </span>PalletACall {
		<span class="attr">#[codec(index = <span class="number">0</span>)]
		</span>Foo(String),
	}

	<span class="attr">#[derive(Encode, Decode)]
	</span><span class="kw">pub enum </span>PalletBCall {
		<span class="attr">#[codec(index = <span class="number">0</span>)]
		</span>Bar(String),
	}
}</code></pre></div>
<p>In pseudo-code, this <code>Call</code> enum encodes equivalently to:</p>
<div class="example-wrap"><pre class="language-text"><code>call_data = concat(
    pallet_index,
    call_index,
    call_args
)
</code></pre></div>
<ul>
<li><code>pallet_index</code> is a single byte denoting the index of the pallet that we are calling into, and
is what the tag of the outermost enum will encode to.</li>
<li><code>call_index</code> is a single byte denoting the index of the call that we are making the pallet,
and is what the tag of the inner enum will encode to.</li>
<li><code>call_args</code> are the SCALE encoded bytes for each of the arguments that the call expects, and
are typically provided as values to the inner enum.</li>
</ul>
<p>Information about the pallets that exist for a chain (including their indexes), the calls
available in each pallet (including their indexes), and the arguments required for each call
can be found in the metadata for the chain. For V15 metadata, this information
[is here][frame::deps::frame_support::__private::metadata::v15::PalletMetadata].</p>
<h2 id="the-signed-payload-format"><a class="doc-anchor" href="#the-signed-payload-format">§</a>The Signed Payload Format</h2>
<p>All extrinsics submitted to a node from the outside world (also known as <em>transactions</em>) need to
be <em>signed</em>. The data that needs to be signed for some extrinsic is called the <em>signed payload</em>,
and its shape is described by the following pseudo-code:</p>
<div class="example-wrap"><pre class="language-text"><code>signed_payload = concat(
    call_data,
    signed_extensions_extra,
    signed_extensions_additional,
)

if length(signed_payload) &gt; 256 {
    signed_payload = blake2_256(signed_payload)
}
</code></pre></div>
<p>The bytes representing <code>call_data</code> and <code>signed_extensions_extra</code> can be obtained as described
above. <code>signed_extensions_additional</code> is constructed by SCALE encoding the
<a href="../../../sp_runtime/traits/trait.SignedExtension.html#associatedtype.AdditionalSigned" title="associated type sp_runtime::traits::SignedExtension::AdditionalSigned">“additional signed” data</a> for each
signed extension that the chain is using, in order.</p>
<p>Once we’ve concatenated those together, we hash the result if it’s greater than 256 bytes in
length using a Blake2 256bit hasher.</p>
<p>The <a href="../../../sp_runtime/generic/unchecked_extrinsic/struct.SignedPayload.html" title="struct sp_runtime::generic::unchecked_extrinsic::SignedPayload"><code>sp_runtime::generic::SignedPayload</code></a> type takes care of assembling the correct payload
for us, given <code>call_data</code> and a tuple of signed extensions.</p>
<h2 id="example-encoding"><a class="doc-anchor" href="#example-encoding">§</a>Example Encoding</h2>
<p>Using <a href="../../../sp_runtime/generic/unchecked_extrinsic/struct.UncheckedExtrinsic.html" title="struct sp_runtime::generic::unchecked_extrinsic::UncheckedExtrinsic"><code>sp_runtime::generic::UncheckedExtrinsic</code></a>, we can construct and encode an extrinsic
as follows:</p>

<div class="example-wrap ignore"><a href="#" class="tooltip" title="This example is not tested">ⓘ</a><pre class="rust rust-example-rendered"><code><span class="kw">pub mod </span>encoding_example {
	<span class="kw">use </span><span class="kw">super</span>::call_data::{Call, PalletACall};
	<span class="kw">use </span><span class="kw">crate</span>::reference_docs::signed_extensions::signed_extensions_example;
	<span class="kw">use </span>codec::Encode;
	<span class="kw">use </span>sp_core::crypto::AccountId32;
	<span class="kw">use </span>sp_keyring::sr25519::Keyring;
	<span class="kw">use </span>sp_runtime::{
		generic::{SignedPayload, UncheckedExtrinsic},
		MultiAddress, MultiSignature,
	};

	<span class="comment">// Define some signed extensions to use. We'll use a couple of examples
	// from the signed extensions reference doc.
	</span><span class="kw">type </span>SignedExtensions =
		(signed_extensions_example::AddToPayload, signed_extensions_example::AddToSignaturePayload);

	<span class="comment">// We'll use `UncheckedExtrinsic` to encode our extrinsic for us. We set
	// the address and signature type to those used on bitzal, use our custom
	// `Call` type, and use our custom set of `SignedExtensions`.
	</span><span class="kw">type </span>Extrinsic =
		UncheckedExtrinsic&lt;MultiAddress&lt;AccountId32, ()&gt;, Call, MultiSignature, SignedExtensions&gt;;

	<span class="kw">pub fn </span>encode_demo_extrinsic() -&gt; Vec&lt;u8&gt; {
		<span class="comment">// The "from" address will be our Alice dev account.
		</span><span class="kw">let </span>from_address = MultiAddress::&lt;AccountId32, ()&gt;::Id(Keyring::Alice.to_account_id());

		<span class="comment">// We provide some values for our expected signed extensions.
		</span><span class="kw">let </span>signed_extensions = (
			signed_extensions_example::AddToPayload(<span class="number">1</span>),
			signed_extensions_example::AddToSignaturePayload,
		);

		<span class="comment">// Construct our call data:
		</span><span class="kw">let </span>call_data = Call::PalletA(PalletACall::Foo(<span class="string">"Hello"</span>.to_string()));

		<span class="comment">// The signed payload. This takes care of encoding the call_data,
		// signed_extensions_extra and signed_extensions_additional, and hashing
		// the result if it's &gt; 256 bytes:
		</span><span class="kw">let </span>signed_payload = SignedPayload::new(<span class="kw-2">&amp;</span>call_data, signed_extensions.clone());

		<span class="comment">// Sign the signed payload with our Alice dev account's private key,
		// and wrap the signature into the expected type:
		</span><span class="kw">let </span>signature = {
			<span class="kw">let </span>sig = Keyring::Alice.sign(<span class="kw-2">&amp;</span>signed_payload.encode());
			MultiSignature::Sr25519(sig)
		};

		<span class="comment">// Now, we can build and encode our extrinsic:
		</span><span class="kw">let </span>ext = Extrinsic::new_signed(call_data, from_address, signature, signed_extensions);

		<span class="kw">let </span>encoded_ext = ext.encode();
		encoded_ext
	}
}</code></pre></div>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="mod" href="call_data/index.html" title="mod bitzal_sdk_docs::reference_docs::extrinsic_encoding::call_data">call_data</a></div></li><li><div class="item-name"><a class="mod" href="encoding_example/index.html" title="mod bitzal_sdk_docs::reference_docs::extrinsic_encoding::encoding_example">encoding_example</a></div></li></ul></section></div></main><script> mermaid.init({ startOnLoad: true, theme: "dark" }, "pre.language-mermaid > code");</script>


</body></html>